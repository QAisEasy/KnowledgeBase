{
    "id": "1.1.1",
    "title": "Общие знания тестирования - Уровень 1: Базовые концепции",
    "questions": [
      {
        "id": "1.1.1.1",
        "question": "Согласно модели Кано, какой тип характеристик качества НЕ создает удовлетворенность при наличии, но создает крайнее недовольство при отсутствии?",
        "options": [
          {"text": "Восхищающие (Delighters)"},
          {"text": "Базовые (Must-have)"},
          {"text": "Ожидаемые (Performance)"},
          {"text": "Безразличные (Indifferent)"}
        ],
        "correctAnswer": 1,
        "explanations": [
          {
            "correct": "Неверно. Восхищающие характеристики создают удовлетворенность при наличии, их отсутствие не вызывает недовольства, так как пользователи их не ожидают.",
            "incorrect": "Неверно. Восхищающие характеристики создают удовлетворенность при наличии, их отсутствие не вызывает недовольства, так как пользователи их не ожидают."
          },
          {
            "correct": "Правильно! Базовые характеристики воспринимаются как само собой разумеющиеся. Их наличие не создает удовлетворенности (это норма), но отсутствие вызывает крайнее недовольство.",
            "incorrect": "Правильно! Базовые характеристики воспринимаются как само собой разумеющиеся. Их наличие не создает удовлетворенности (это норма), но отсутствие вызывает крайнее недовольство."
          },
          {
            "correct": "Неверно. Ожидаемые характеристики имеют линейную зависимость: чем больше/лучше, тем выше удовлетворенность.",
            "incorrect": "Неверно. Ожидаемые характеристики имеют линейную зависимость: чем больше/лучше, тем выше удовлетворенность."
          },
          {
            "correct": "Неверно. Безразличные характеристики не влияют на удовлетворенность ни при наличии, ни при отсутствии.",
            "incorrect": "Неверно. Безразличные характеристики не влияют на удовлетворенность ни при наличии, ни при отсутствии."
          }
        ]
      },
      {
        "id": "1.1.1.2",
        "question": "Какой вид тестирования лучше всего подходит для проверки базовой жизнеспособности системы после новой сборки?",
        "options": [
          {"text": "Regression Testing"},
          {"text": "Smoke Testing"},
          {"text": "Performance Testing"},
          {"text": "UAT (User Acceptance Testing)"}
        ],
        "correctAnswer": 1,
        "explanations": [
          {
            "correct": "Неверно. Regression Testing проверяет, что новые изменения не сломали существующую функциональность, это более глубокая и длительная проверка.",
            "incorrect": "Неверно. Regression Testing проверяет, что новые изменения не сломали существующую функциональность, это более глубокая и длительная проверка."
          },
          {
            "correct": "Правильно! Smoke Testing — это минимальный набор тестов для быстрой проверки базовой работоспособности системы. Обычно занимает 5-30 минут и выполняется после каждой сборки.",
            "incorrect": "Правильно! Smoke Testing — это минимальный набор тестов для быстрой проверки базовой работоспособности системы. Обычно занимает 5-30 минут и выполняется после каждой сборки."
          },
          {
            "correct": "Неверно. Performance Testing проверяет производительность системы под нагрузкой, это специализированный вид тестирования, не подходящий для базовой проверки.",
            "incorrect": "Неверно. Performance Testing проверяет производительность системы под нагрузкой, это специализированный вид тестирования, не подходящий для базовой проверки."
          },
          {
            "correct": "Неверно. UAT выполняется пользователями или их представителями для финальной проверки готовности к production, это завершающий этап.",
            "incorrect": "Неверно. UAT выполняется пользователями или их представителями для финальной проверки готовности к production, это завершающий этап."
          }
        ]
      },
      {
        "id": "1.1.1.3",
        "question": "Согласно пирамиде тестирования, какой уровень должен содержать наибольшее количество тестов?",
        "options": [
          {"text": "System Testing"},
          {"text": "Integration Testing"},
          {"text": "Unit Testing"},
          {"text": "Acceptance Testing"}
        ],
        "correctAnswer": 2,
        "explanations": [
          {
            "correct": "Неверно. System Testing находится ближе к вершине пирамиды и должен содержать меньше тестов (около 15% от общего числа).",
            "incorrect": "Неверно. System Testing находится ближе к вершине пирамиды и должен содержать меньше тестов (около 15% от общего числа)."
          },
          {
            "correct": "Неверно. Integration Testing находится в середине пирамиды и составляет около 20% тестов.",
            "incorrect": "Неверно. Integration Testing находится в середине пирамиды и составляет около 20% тестов."
          },
          {
            "correct": "Правильно! Unit Testing формирует основание пирамиды и должен составлять около 60% всех тестов. Эти тесты быстрые, стабильные и дешевые в поддержке.",
            "incorrect": "Правильно! Unit Testing формирует основание пирамиды и должен составлять около 60% всех тестов. Эти тесты быстрые, стабильные и дешевые в поддержке."
          },
          {
            "correct": "Неверно. Acceptance Testing находится на вершине пирамиды и составляет всего около 5% тестов из-за их сложности и длительности выполнения.",
            "incorrect": "Неверно. Acceptance Testing находится на вершине пирамиды и составляет всего около 5% тестов из-за их сложности и длительности выполнения."
          }
        ]
      },
      {
        "id": "1.1.1.4",
        "question": "В каком состоянии находится дефект, когда разработчик завершил исправление, но тестировщик еще не проверил его?",
        "options": [
          {"text": "Verified"},
          {"text": "In Progress"},
          {"text": "Fixed/Resolved"},
          {"text": "Closed"}
        ],
        "correctAnswer": 2,
        "explanations": [
          {
            "correct": "Неверно. Verified означает, что тестировщик уже проверил исправление и подтвердил, что дефект больше не воспроизводится.",
            "incorrect": "Неверно. Verified означает, что тестировщик уже проверил исправление и подтвердил, что дефект больше не воспроизводится."
          },
          {
            "correct": "Неверно. In Progress означает, что разработчик в данный момент работает над исправлением дефекта.",
            "incorrect": "Неверно. In Progress означает, что разработчик в данный момент работает над исправлением дефекта."
          },
          {
            "correct": "Правильно! Fixed/Resolved — это состояние, когда разработчик завершил работу над дефектом, но исправление еще не проверено тестировщиком.",
            "incorrect": "Правильно! Fixed/Resolved — это состояние, когда разработчик завершил работу над дефектом, но исправление еще не проверено тестировщиком."
          },
          {
            "correct": "Неверно. Closed — финальное состояние после того, как тестировщик проверил исправление и подтвердил, что дефект устранен.",
            "incorrect": "Неверно. Closed — финальное состояние после того, как тестировщик проверил исправление и подтвердил, что дефект устранен."
          }
        ]
      },
      {
        "id": "1.1.1.5",
        "question": "Чем отличается Verification от Validation согласно классическому определению Барри Боэма?",
        "options": [
          {"text": "Verification проверяет соответствие бизнес-требованиям, Validation — техническим спецификациям"},
          {"text": "Verification — это тестирование, Validation — это отладка"},
          {"text": "Verification отвечает на вопрос 'Правильно ли мы строим продукт?', Validation — 'Правильный ли продукт мы строим?'"},
          {"text": "Verification выполняется разработчиками, Validation — тестировщиками"}
        ],
        "correctAnswer": 2,
        "explanations": [
          {
            "correct": "Неверно. Это противоположно правильному определению. Verification проверяет техническое соответствие, а Validation — соответствие потребностям пользователя.",
            "incorrect": "Неверно. Это противоположно правильному определению. Verification проверяет техническое соответствие, а Validation — соответствие потребностям пользователя."
          },
          {
            "correct": "Неверно. И Verification, и Validation являются процессами проверки качества. Отладка (debugging) — это процесс исправления найденных дефектов.",
            "incorrect": "Неверно. И Verification, и Validation являются процессами проверки качества. Отладка (debugging) — это процесс исправления найденных дефектов."
          },
          {
            "correct": "Правильно! Verification проверяет соответствие продукта спецификациям (КАК?), а Validation проверяет соответствие потребностям пользователя (ЧТО? и ЗАЧЕМ?).",
            "incorrect": "Правильно! Verification проверяет соответствие продукта спецификациям (КАК?), а Validation проверяет соответствие потребностям пользователя (ЧТО? и ЗАЧЕМ?)."
          },
          {
            "correct": "Неверно. Оба процесса могут выполняться как разработчиками, так и тестировщиками. Разница в фокусе проверки, а не в исполнителях.",
            "incorrect": "Неверно. Оба процесса могут выполняться как разработчиками, так и тестировщиками. Разница в фокусе проверки, а не в исполнителях."
          }
        ]
      },
      {
        "id": "1.1.1.6",
        "question": "Какое окружение обычно используется для финальной проверки перед релизом и максимально приближено к production?",
        "options": [
          {"text": "Development"},
          {"text": "Test/QA"},
          {"text": "Staging/Pre-production"},
          {"text": "Local"}
        ],
        "correctAnswer": 2,
        "explanations": [
          {
            "correct": "Неверно. Development окружение используется для интеграции кода разработчиков, оно нестабильное и часто обновляется.",
            "incorrect": "Неверно. Development окружение используется для интеграции кода разработчиков, оно нестабильное и часто обновляется."
          },
          {
            "correct": "Неверно. Test/QA окружение используется для основного тестирования, но его конфигурация может отличаться от production.",
            "incorrect": "Неверно. Test/QA окружение используется для основного тестирования, но его конфигурация может отличаться от production."
          },
          {
            "correct": "Правильно! Staging/Pre-production — это окружение с идентичной production инфраструктурой, используемое для финальной проверки перед релизом.",
            "incorrect": "Правильно! Staging/Pre-production — это окружение с идентичной production инфраструктурой, используемое для финальной проверки перед релизом."
          },
          {
            "correct": "Неверно. Local — это личная среда разработчика для написания и первичной отладки кода, максимально отличающаяся от production.",
            "incorrect": "Неверно. Local — это личная среда разработчика для написания и первичной отладки кода, максимально отличающаяся от production."
          }
        ]
      },
      {
        "id": "1.1.1.7",
        "question": "Если в банковском приложении кнопка 'Перевести деньги' иногда не активируется после ввода данных, какой приоритет следует присвоить этому дефекту?",
        "options": [
          {"text": "Low (P4) - косметическая проблема"},
          {"text": "Medium (P3) - можно отложить"},
          {"text": "High (P2) - важно для релиза"},
          {"text": "Critical (P1) - исправить немедленно"}
        ],
        "correctAnswer": 3,
        "explanations": [
          {
            "correct": "Неверно. Невозможность выполнить перевод денег — это критическая функциональность банковского приложения, а не косметическая проблема.",
            "incorrect": "Неверно. Невозможность выполнить перевод денег — это критическая функциональность банковского приложения, а не косметическая проблема."
          },
          {
            "correct": "Неверно. Основная функция банковского приложения не может быть отложена на будущее.",
            "incorrect": "Неверно. Основная функция банковского приложения не может быть отложена на будущее."
          },
          {
            "correct": "Неверно. Хотя проблема возникает 'иногда', перевод денег — базовая функция банковского приложения, требующая немедленного внимания.",
            "incorrect": "Неверно. Хотя проблема возникает 'иногда', перевод денег — базовая функция банковского приложения, требующая немедленного внимания."
          },
          {
            "correct": "Правильно! Даже если проблема возникает периодически, невозможность выполнить перевод — это нарушение базовой функциональности банковского приложения, требующее немедленного исправления.",
            "incorrect": "Правильно! Даже если проблема возникает периодически, невозможность выполнить перевод — это нарушение базовой функциональности банковского приложения, требующее немедленного исправления."
          }
        ]
      },
      {
        "id": "1.1.1.8",
        "question": "Что из перечисленного является примером White Box тестирования?",
        "options": [
          {"text": "Проверка, что при вводе логина и пароля происходит вход в систему"},
          {"text": "Тестирование покрытия всех ветвей алгоритма сортировки"},
          {"text": "Проверка удобства интерфейса пользователями"},
          {"text": "Тестирование совместимости с разными браузерами"}
        ],
        "correctAnswer": 1,
        "explanations": [
          {
            "correct": "Неверно. Это пример Black Box тестирования — проверяется функциональность без знания внутренней реализации.",
            "incorrect": "Неверно. Это пример Black Box тестирования — проверяется функциональность без знания внутренней реализации."
          },
          {
            "correct": "Правильно! Тестирование покрытия ветвей алгоритма требует знания внутренней структуры кода, что является характеристикой White Box тестирования.",
            "incorrect": "Правильно! Тестирование покрытия ветвей алгоритма требует знания внутренней структуры кода, что является характеристикой White Box тестирования."
          },
          {
            "correct": "Неверно. Usability тестирование относится к Black Box подходу, так как фокусируется на пользовательском опыте, а не на коде.",
            "incorrect": "Неверно. Usability тестирование относится к Black Box подходу, так как фокусируется на пользовательском опыте, а не на коде."
          },
          {
            "correct": "Неверно. Compatibility тестирование проверяет работу системы в разных условиях без необходимости знать внутреннюю реализацию.",
            "incorrect": "Неверно. Compatibility тестирование проверяет работу системы в разных условиях без необходимости знать внутреннюю реализацию."
          }
        ]
      },
      {
        "id": "1.1.1.9",
        "question": "В чем ключевое отличие тест-кейса от чек-листа?",
        "options": [
          {"text": "Тест-кейс используется только для автоматизации"},
          {"text": "Чек-лист содержит детальные шаги выполнения"},
          {"text": "Тест-кейс содержит пошаговые инструкции и ожидаемые результаты, чек-лист — список проверок без деталей"},
          {"text": "Чек-лист используется только для regression тестирования"}
        ],
        "correctAnswer": 2,
        "explanations": [
          {
            "correct": "Неверно. Тест-кейсы используются как для ручного, так и для автоматизированного тестирования.",
            "incorrect": "Неверно. Тест-кейсы используются как для ручного, так и для автоматизированного тестирования."
          },
          {
            "correct": "Неверно. Наоборот, чек-лист содержит список проверок без детальных шагов, это его ключевая особенность.",
            "incorrect": "Неверно. Наоборот, чек-лист содержит список проверок без детальных шагов, это его ключевая особенность."
          },
          {
            "correct": "Правильно! Тест-кейс — это формальный документ с детальными шагами и ожидаемыми результатами, а чек-лист — более гибкий список проверок для опытных тестировщиков.",
            "incorrect": "Правильно! Тест-кейс — это формальный документ с детальными шагами и ожидаемыми результатами, а чек-лист — более гибкий список проверок для опытных тестировщиков."
          },
          {
            "correct": "Неверно. Чек-листы могут использоваться для любого вида тестирования, особенно эффективны для исследовательского тестирования.",
            "incorrect": "Неверно. Чек-листы могут использоваться для любого вида тестирования, особенно эффективны для исследовательского тестирования."
          }
        ]
      },
      {
        "id": "1.1.1.10",
        "question": "Какой процент дефектов обычно обнаруживается на уровне Integration Testing согласно статистике?",
        "options": [
          {"text": "10%"},
          {"text": "30%"},
          {"text": "50%"},
          {"text": "70%"}
        ],
        "correctAnswer": 1,
        "explanations": [
          {
            "correct": "Неверно. 10% — это примерная доля дефектов, обнаруживаемых на уровне Acceptance Testing.",
            "incorrect": "Неверно. 10% — это примерная доля дефектов, обнаруживаемых на уровне Acceptance Testing."
          },
          {
            "correct": "Правильно! Integration Testing обычно находит около 30% всех дефектов, в основном связанных с взаимодействием компонентов и несоответствием интерфейсов.",
            "incorrect": "Правильно! Integration Testing обычно находит около 30% всех дефектов, в основном связанных с взаимодействием компонентов и несоответствием интерфейсов."
          },
          {
            "correct": "Неверно. Такой высокий процент не характерен для одного уровня тестирования.",
            "incorrect": "Неверно. Такой высокий процент не характерен для одного уровня тестирования."
          },
          {
            "correct": "Неверно. Это слишком высокий показатель для одного уровня. Unit Testing находит 35%, Integration — 30%, System — 25%, Acceptance — 10%.",
            "incorrect": "Неверно. Это слишком высокий показатель для одного уровня. Unit Testing находит 35%, Integration — 30%, System — 25%, Acceptance — 10%."
          }
        ]
      },
      {
        "id": "1.1.1.11",
        "question": "Когда дефект получает статус 'Deferred/Postponed'?",
        "options": [
          {"text": "Когда невозможно воспроизвести проблему"},
          {"text": "Когда дефект уже исправлен в другой задаче"},
          {"text": "Когда принято решение отложить исправление на будущее"},
          {"text": "Когда дефект не является ошибкой (работает как задумано)"}
        ],
        "correctAnswer": 2,
        "explanations": [
          {
            "correct": "Неверно. При невозможности воспроизведения дефект обычно получает статус Rejected/Cannot Reproduce.",
            "incorrect": "Неверно. При невозможности воспроизведения дефект обычно получает статус Rejected/Cannot Reproduce."
          },
          {
            "correct": "Неверно. Если дефект уже исправлен, он обычно закрывается как Duplicate с указанием связанной задачи.",
            "incorrect": "Неверно. Если дефект уже исправлен, он обычно закрывается как Duplicate с указанием связанной задачи."
          },
          {
            "correct": "Правильно! Deferred/Postponed означает, что дефект признан, но его исправление отложено из-за низкого приоритета, ограниченных ресурсов или планируемого рефакторинга.",
            "incorrect": "Правильно! Deferred/Postponed означает, что дефект признан, но его исправление отложено из-за низкого приоритета, ограниченных ресурсов или планируемого рефакторинга."
          },
          {
            "correct": "Неверно. В этом случае дефект отклоняется со статусом Not a Bug или Works as Designed.",
            "incorrect": "Неверно. В этом случае дефект отклоняется со статусом Not a Bug или Works as Designed."
          }
        ]
      },
      {
        "id": "1.1.1.12",
        "question": "Какая характеристика качества по модели Кано со временем обычно эволюционирует из 'восхищающей' в 'базовую'?",
        "options": [
          {"text": "Только визуальные улучшения"},
          {"text": "Только функции безопасности"},
          {"text": "Любая инновационная функция при широком распространении"},
          {"text": "Только производительность системы"}
        ],
        "correctAnswer": 2,
        "explanations": [
          {
            "correct": "Неверно. Эволюция касается не только визуальных аспектов. Например, тачскрин был восхищающей характеристикой в 2007, а сейчас — базовая.",
            "incorrect": "Неверно. Эволюция касается не только визуальных аспектов. Например, тачскрин был восхищающей характеристикой в 2007, а сейчас — базовая."
          },
          {
            "correct": "Неверно. Безопасность часто изначально является базовой характеристикой, а не восхищающей.",
            "incorrect": "Неверно. Безопасность часто изначально является базовой характеристикой, а не восхищающей."
          },
          {
            "correct": "Правильно! Любая инновация следует циклу: восхищающая → ожидаемая → базовая. Примеры: автосохранение, email, смартфоны, dark mode.",
            "incorrect": "Правильно! Любая инновация следует циклу: восхищающая → ожидаемая → базовая. Примеры: автосохранение, email, смартфоны, dark mode."
          },
          {
            "correct": "Неверно. Производительность обычно относится к ожидаемым характеристикам с линейной зависимостью удовлетворенности.",
            "incorrect": "Неверно. Производительность обычно относится к ожидаемым характеристикам с линейной зависимостью удовлетворенности."
          }
        ]
      },
      {
        "id": "1.1.1.13",
        "question": "В каком окружении обычно используются обезличенные данные из production?",
        "options": [
          {"text": "Local Development"},
          {"text": "Development (Dev)"},
          {"text": "Test/QA"},
          {"text": "Staging/Pre-production"}
        ],
        "correctAnswer": 3,
        "explanations": [
          {
            "correct": "Неверно. В Local окружении используется минимальный набор данных или in-memory базы для быстрой разработки.",
            "incorrect": "Неверно. В Local окружении используется минимальный набор данных или in-memory базы для быстрой разработки."
          },
          {
            "correct": "Неверно. В Dev окружении обычно используются синтетические данные, база может очищаться ежедневно.",
            "incorrect": "Неверно. В Dev окружении обычно используются синтетические данные, база может очищаться ежедневно."
          },
          {
            "correct": "Неверно. В Test/QA используются специально подготовленные тестовые данные, покрывающие различные сценарии.",
            "incorrect": "Неверно. В Test/QA используются специально подготовленные тестовые данные, покрывающие различные сценарии."
          },
          {
            "correct": "Правильно! Staging использует обезличенную копию production данных для максимально реалистичного тестирования перед релизом.",
            "incorrect": "Правильно! Staging использует обезличенную копию production данных для максимально реалистичного тестирования перед релизом."
          }
        ]
      },
      {
        "id": "1.1.1.14",
        "question": "Что означает термин 'Regression Testing'?",
        "options": [
          {"text": "Тестирование старых версий продукта"},
          {"text": "Проверка, что новые изменения не нарушили существующую функциональность"},
          {"text": "Тестирование производительности под нагрузкой"},
          {"text": "Возврат к предыдущей версии после неудачного релиза"}
        ],
        "correctAnswer": 1,
        "explanations": [
          {
            "correct": "Неверно. Это распространенное заблуждение. Regression testing не связано с тестированием старых версий.",
            "incorrect": "Неверно. Это распространенное заблуждение. Regression testing не связано с тестированием старых версий."
          },
          {
            "correct": "Правильно! Regression Testing проверяет, что новые изменения в коде не привели к появлению дефектов в ранее работавшей функциональности.",
            "incorrect": "Правильно! Regression Testing проверяет, что новые изменения в коде не привели к появлению дефектов в ранее работавшей функциональности."
          },
          {
            "correct": "Неверно. Тестирование производительности — это Performance Testing, отдельный вид нефункционального тестирования.",
            "incorrect": "Неверно. Тестирование производительности — это Performance Testing, отдельный вид нефункционального тестирования."
          },
          {
            "correct": "Неверно. Возврат к предыдущей версии называется Rollback, это не связано с regression testing.",
            "incorrect": "Неверно. Возврат к предыдущей версии называется Rollback, это не связано с regression testing."
          }
        ]
      },
      {
        "id": "1.1.1.15",
        "question": "Какой подход к интеграционному тестированию требует создания заглушек (stubs) для нижних уровней системы?",
        "options": [
          {"text": "Big Bang"},
          {"text": "Bottom-Up"},
          {"text": "Top-Down"},
          {"text": "Sandwich/Hybrid"}
        ],
        "correctAnswer": 2,
        "explanations": [
          {
            "correct": "Неверно. Big Bang подход интегрирует все модули одновременно, не требуя заглушек или драйверов.",
            "incorrect": "Неверно. Big Bang подход интегрирует все модули одновременно, не требуя заглушек или драйверов."
          },
          {
            "correct": "Неверно. Bottom-Up подход начинает с нижних уровней и требует создания драйверов для их тестирования, а не заглушек.",
            "incorrect": "Неверно. Bottom-Up подход начинает с нижних уровней и требует создания драйверов для их тестирования, а не заглушек."
          },
          {
            "correct": "Правильно! Top-Down подход начинает тестирование с верхнего уровня системы, поэтому требует создания заглушек (stubs) для имитации еще не реализованных нижних уровней.",
            "incorrect": "Правильно! Top-Down подход начинает тестирование с верхнего уровня системы, поэтому требует создания заглушек (stubs) для имитации еще не реализованных нижних уровней."
          },
          {
            "correct": "Неверно. Sandwich подход комбинирует Top-Down и Bottom-Up, используя как заглушки, так и драйверы, но вопрос спрашивает о подходе, который требует именно заглушек.",
            "incorrect": "Неверно. Sandwich подход комбинирует Top-Down и Bottom-Up, используя как заглушки, так и драйверы, но вопрос спрашивает о подходе, который требует именно заглушек."
          }
        ]
      }
    ]
  }